package dev.danvega.contentcalendar.controller;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import dev.danvega.contentcalendar.model.Content;
import dev.danvega.contentcalendar.repository.ContentRepository;
import jakarta.validation.Valid;

@RestController
/*
 * Indicates that this class is a Spring MVC controller where 
 * every method returns a Java object that is automatically serialized to JSON.
 */
@RequestMapping("/api/content")
/*
 * Maps all requests that start with /api/content to this controller.
 */
public class ContentController {
    /*
     * instance is declared to perform CRUD operations on Content.
        The constructor injects the repository through dependency injection.
     */
    /*
     * repository is the object to interact with database,
     * to use manual connect database, amend below line.
     * methods are: findall, findbyId,
     */
    private final ContentRepository repository;

    public ContentController(ContentRepository repository) {
        this.repository = repository;
    }
    /*
     * Endpoint: GET /api/content
     * Returns a list of all Content entities from the database.
     */
    @GetMapping
    public List<Content> findAll() {
        return repository.findAll();
    }
    /*
     * Endpoint: GET /api/content/{id}
        Accepts a path variable id.
        Fetches the Content entity with the specified id.
        If not found, throws a ResponseStatusException with a 404 NOT FOUND status.
     */
    @GetMapping("/{id}")
    public Optional<Content> findById(@PathVariable Integer id) {
        return Optional.ofNullable(repository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Content not found.")));
    }
    /*
     * Endpoint: POST /api/content
        Accepts a JSON object in the request body which matches the Content class structure.
        The content entity is validated using @Valid and saved to the repository.
        Responds with a 201 CREATED status.
    */
    @ResponseStatus(HttpStatus.CREATED)
    @PostMapping
    public void create(@Valid @RequestBody Content content) {
        // Set the created date to now
    content = new Content(
        null, // ID will be autogenerated
        content.title(),
        content.desc(),
        content.status(),
        content.contentType(),
        LocalDateTime.now(), // Set dateCreated
        null, // dateUpdated can be null at creation
        content.url()
    );
        repository.save(content);
    }
    /*
     * Endpoint: PUT /api/content/{id}
        Accepts a JSON object and an id as path variable.
        Validates that the Content exists; if not, throws a 404 NOT FOUND status.
        If it exists, it saves (updates) the Content.
     */
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @PutMapping("/{id}")
    public void update(@Valid @RequestBody Content content, @PathVariable Integer id) {
    // Check if the content exists
    Content existingContent = repository.findById(id)
        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Content not found."));

    // Create an updated instance with preserved dateCreated and set the dateUpdated
    Content updatedContent = new Content(
        id,                            // use the existing ID
        content.title(),            // new title
        content.desc(),             // new description
        content.status(),           // new status
        content.contentType(),      // new content type
        existingContent.dateCreated(), // preserve the existing dateCreated
        LocalDateTime.now(),           // set the current time for dateUpdated
        content.url()               // new URL
    );

    // Save the updated content
    repository.save(updatedContent);
    }

/*
 * Endpoint: DELETE /api/content/{id}
Deletes the Content with the given id.
Responds with a 204 NO CONTENT status.
 */
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @DeleteMapping("/{id}")
    public void delete(@PathVariable Integer id) {
        repository.deleteById(id);
    }
/*
 * Endpoint: GET /api/content/filter/type/{type}
    Accepts a path variable type.
    Returns a list of Content filtered by the provided content type 
    (converted to uppercase).
 */
    @GetMapping("/filter/type/{type}")
    public List<Content> filterByType(@PathVariable String type) {
        return repository.findAllByContentType(type.toUpperCase());
    }
}
